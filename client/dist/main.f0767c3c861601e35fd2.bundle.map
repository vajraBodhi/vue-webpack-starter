{"version":3,"sources":["webpack:///main.f0767c3c861601e35fd2.bundle.js","webpack:///./C:/zzPersonal/vue-webpack-starter/client/src/main.js","webpack:///./C:/zzPersonal/vue-webpack-starter/client/src/routes/migration/index.js","webpack:///./C:/zzPersonal/vue-webpack-starter/client/src/routes/migration/migration.js"],"names":["webpackJsonp","module","exports","__webpack_require__","window","map","mOverlay","onload","data","qq","maps","Map","document","getElementById","zoom","center","LatLng","mapTypeId","MapTypeId","ROADMAP","QQMapPlugin","MigrationOverlay","JSON","parse","Label","position","content","style","borderStyle","color","backgroundColor","offset","Size","utils","calculateColor","opacity","indexOf","color16","slice","r","parseInt","g","b","test","replace","split","splice","join","arrayUtils","forEach","arr","cb","scope","Array","prototype","i","len","length","apply","mapped","Marker","M","options","this","x","y","rotation","size","borderWidth","borderColor","draw","context","save","translate","rotate","lineWidth","strokeStyle","fillStyle","beginPath","arc","Math","PI","moveTo","lineTo","closePath","stroke","fill","restore","Arc","A","startX","startY","endX","endY","L","sqrt","pow","m","n","factor","centerX","centerY","radius","startAngle","atan2","endAngle","startLabel","labels","endLabel","width","shadowBlur","shadowColor","font","fillText","Pulse","P","maxRadius","vr","strokeColor","abs","Spark","S","tailPointsCount","deltaAngle","min","trailAngle","arcAngle","animateBlur","marker","drawArc","lineCap","angle","count","arcColor","tailLineWidth","cos","sin","Migration","store","arcs","markers","pulses","sparks","playAnimation","started","init","updateData","add","Shape","remove","clear","cancelAnimationFrame","requestAnimationId","element","from","to","pulse","spark","push","start","canvas","that","drawFrame","requestAnimationFrame","p","shapes","play","pause","cfg","setMap","config","Overlay","call","mapHandles","construct","createElement","getContext","getPanes","overlayLayer","appendChild","resize","migration","convertData","bindMapEvents","constructed","draging","event","addListener","console","info","onresize","containerStyle","getComputedStyle","getContainer","className","setAttribute","height","transform","bounds","getBounds","topLeft","getNorthEast","getLat","getSouthWest","getLng","projection","getProjection","point","fromLatLngToDivPixel","round","layerOffset","d","fromPixel","toPixel","getX","getY","value","setData","show","display","hide","destroy","parentNode","removeChild","handle","mpas","removeListener"],"mappings":"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","file":"main.f0767c3c861601e35fd2.bundle.js","sourcesContent":["webpackJsonp([1],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar MigrationOverlay = __webpack_require__(1);\n\t\n\twindow.map = null, window.mOverlay = null, window.onload = function () {\n\t  var data = '[{\"from\":[113.26627,23.13171],\"to\":[108.32754,22.81521],\"labels\":[null,\"广西\"],\"color\":\"#ff3a31\"},{\"from\":[113.26627,23.13171],\"to\":[112.9834,28.11266],\"labels\":[null,\"湖南\"],\"color\":\"#ff7e2b\"},{\"from\":[113.26627,23.13171],\"to\":[115.91004,28.67417],\"labels\":[null,\"江西\"],\"color\":\"#ffc726\"},{\"from\":[113.26627,23.13171],\"to\":[114.34234,30.54539],\"labels\":[null,\"湖北\"],\"color\":\"#e9ff20\"},{\"from\":[113.26627,23.13171],\"to\":[119.29659,26.09982],\"labels\":[null,\"福建\"],\"color\":\"#99ff1b\"},{\"from\":[113.26627,23.13171],\"to\":[106.70722,26.5982],\"labels\":[null,\"贵州\"],\"color\":\"#45ff15\"},{\"from\":[113.26627,23.13171],\"to\":[104.07572,30.65089],\"labels\":[null,\"四川\"],\"color\":\"#10ff33\"},{\"from\":[113.26627,23.13171],\"to\":[120.1536,30.26555],\"labels\":[null,\"浙江\"],\"color\":\"#0aff84\"},{\"from\":[113.26627,23.13171],\"to\":[121.4737,31.23037],\"labels\":[null,\"上海\"],\"color\":\"#05ffd9\"},{\"from\":[113.26627,23.13171],\"to\":[113.75322,34.76571],\"labels\":[null,\"河南\"],\"color\":\"#00ccff\"}]';\n\t  window.map = new qq.maps.Map(document.getElementById(\"map_container\"), {\n\t    zoom: 4,\n\t    center: new qq.maps.LatLng(37.43496995956318, 106.92269849999998),\n\t    mapTypeId: qq.maps.MapTypeId.ROADMAP\n\t  });\n\t  window.mOverlay = new QQMapPlugin.MigrationOverlay(window.map, { data: JSON.parse(data) });\n\t  new qq.maps.Label({\n\t    position: new qq.maps.LatLng(25.735, 123.46777777777777),\n\t    map: window.map, content: \"钓鱼岛\",\n\t    style: { borderStyle: \"none\", color: \"#fff\", backgroundColor: \"transparent\" } }), new qq.maps.Label({\n\t    position: new qq.maps.LatLng(25.9175, 124.55138888888888),\n\t    map: window.map,\n\t    content: \"赤尾屿\",\n\t    offset: new qq.maps.Size(0, -10),\n\t    style: { borderStyle: \"none\", color: \"#fff\", backgroundColor: \"transparent\" }\n\t  });\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar MigrationOverlay = __webpack_require__(2);\n\t\n\tmodule.exports = MigrationOverlay;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t//已知两点和半径求圆心算法：\n\t//http://stackoverflow.com/questions/12264841/determine-circle-center-based-on-two-points-radius-known-with-solve-optim\n\t\n\tvar utils = {\n\t  // color:rgb或rgba格式\n\t  // opacity: 透明度\n\t  calculateColor: function calculateColor(color, opacity) {\n\t    if (color.indexOf('#') === 0) {\n\t      var color16 = color.slice(1);\n\t      var r = parseInt(color16.slice(0, 2), 16);\n\t      var g = parseInt(color16.slice(2, 4), 16);\n\t      var b = parseInt(color16.slice(4), 16);\n\t      return 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';\n\t    } else if (/^rgb\\(/.test(color)) {\n\t      return color.replace(/rgb/, 'rgba').replace(')', \",\") + opacity + ')';\n\t    } else {\n\t      return color.split(',').splice(0, 3).join(',') + opacity + ')';\n\t    }\n\t  }\n\t};\n\tvar arrayUtils = {\n\t  forEach: function forEach(arr, cb, scope) {\n\t    if (typeof Array.prototype.forEach === 'function') {\n\t      arr.forEach(cb, scope);\n\t    } else {\n\t      for (var i = 0, len = arr.length; i < len; i++) {\n\t        cb.apply(scope, [arr[i], i, arr]);\n\t      }\n\t    }\n\t  },\n\t  map: function map(arr, cb, scope) {\n\t    if (typeof Array.prototype.map === 'function') {\n\t      return arr.map(cb, scope);\n\t    } else {\n\t      var mapped = [];\n\t      for (var i = 0, len = arr.length; i < len; i++) {\n\t        mapped[i] = cb.apply(scope, [arr[i], i, arr]);\n\t      }\n\t      return mapped;\n\t    }\n\t  }\n\t};\n\t\n\tvar Marker = function () {\n\t  var M = function M(options) {\n\t    this.x = options.x;\n\t    this.y = options.y;\n\t    this.rotation = options.rotation;\n\t    this.style = options.style;\n\t    this.color = options.color;\n\t    this.size = options.size;\n\t    this.borderWidth = options.borderWidth;\n\t    this.borderColor = options.borderColor;\n\t  };\n\t\n\t  M.prototype.draw = function (context) {\n\t    context.save();\n\t    context.translate(this.x, this.y);\n\t    context.rotate(this.rotation);\n\t\n\t    context.lineWidth = this.borderWidth || 0;\n\t    context.strokeStyle = this.borderColor || '#000';\n\t    context.fillStyle = this.color || '#000';\n\t    // 目前先只支持圆\n\t    context.beginPath();\n\t    if (this.style === 'circle') {\n\t      context.arc(0, 0, this.size, 0, Math.PI * 2, false);\n\t    } else if (this.style === 'arrow') {\n\t      context.moveTo(-this.size, -this.size);\n\t      context.lineTo(this.size, 0);\n\t      context.lineTo(-this.size, this.size);\n\t      context.lineTo(-this.size / 4, 0);\n\t      context.lineTo(-this.size, -this.size);\n\t    }\n\t    context.closePath();\n\t    context.stroke();\n\t    context.fill();\n\t    context.restore();\n\t  };\n\t\n\t  return M;\n\t}();\n\t\n\tvar Arc = function () {\n\t  var A = function A(options) {\n\t    var startX = options.startX,\n\t        startY = options.startY,\n\t        endX = options.endX,\n\t        endY = options.endY;\n\t\n\t    //两点之间的圆有多个，通过两点及半径便可以定出两个圆，根据需要选取其中一个圆\n\t    var L = Math.sqrt(Math.pow(startX - endX, 2) + Math.pow(startY - endY, 2));\n\t    var m = (startX + endX) / 2; // 横轴中点\n\t    var n = (startY + endY) / 2; // 纵轴中点\n\t    var factor = 1.5;\n\t\n\t    var centerX = (startY - endY) * factor + m;\n\t    var centerY = (endX - startX) * factor + n;\n\t\n\t    var radius = Math.sqrt(Math.pow(L / 2, 2) + Math.pow(L * factor, 2));\n\t    var startAngle = Math.atan2(startY - centerY, startX - centerX);\n\t    var endAngle = Math.atan2(endY - centerY, endX - centerX);\n\t\n\t    // this.L = L;\n\t    this.startX = startX;\n\t    this.startY = startY;\n\t    this.endX = endX;\n\t    this.endY = endY;\n\t    this.centerX = centerX;\n\t    this.centerY = centerY;\n\t    this.startAngle = startAngle;\n\t    this.endAngle = endAngle;\n\t    this.startLabel = options && options.labels && options.labels[0], this.endLabel = options && options.labels && options.labels[1], this.radius = radius;\n\t    this.lineWidth = options.width || 1;\n\t    this.strokeStyle = options.color || '#000';\n\t    this.shadowBlur = options.shadowBlur;\n\t  };\n\t\n\t  A.prototype.draw = function (context) {\n\t    context.save();\n\t    context.lineWidth = this.lineWidth;\n\t    context.strokeStyle = this.strokeStyle;\n\t    context.shadowColor = this.strokeStyle;\n\t    context.shadowBlur = this.shadowBlur || 2;\n\t\n\t    context.beginPath();\n\t    context.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, false);\n\t    context.stroke();\n\t    context.restore();\n\t\n\t    context.save();\n\t    context.fillStyle = this.strokeStyle;\n\t    context.font = \"15px sans-serif\";\n\t    if (this.startLabel) {\n\t      var x = this.startLabel.indexOf('澳门') !== -1 ? this.startX - 20 : this.startX;\n\t      var y = this.startLabel.indexOf('澳门') !== -1 ? this.startY + 25 : this.startY;\n\t      context.fillText(this.startLabel, x, y);\n\t    }\n\t    if (this.endLabel) {\n\t      var x = this.endLabel.indexOf('澳门') !== -1 ? this.endX - 20 : this.endX;\n\t      var y = this.endLabel.indexOf('澳门') !== -1 ? this.endY + 25 : this.endY;\n\t      context.fillText(this.endLabel, x, y);\n\t    }\n\t    context.restore();\n\t  };\n\t\n\t  return A;\n\t}();\n\t\n\tvar Pulse = function () {\n\t  function P(options) {\n\t    this.x = options.x;\n\t    this.y = options.y;\n\t    this.maxRadius = options.radius;\n\t    this.color = options.color;\n\t    this.shadowBlur = 5;\n\t    this.lineWidth = options.borderWidth;\n\t    this.r = 0;\n\t    this.factor = 2 / options.radius;\n\t  };\n\t\n\t  P.prototype.draw = function (context) {\n\t    // var vr = (this.maxRadius - this.r) * this.factor;\n\t    var vr = 0.5;\n\t    this.r += vr;\n\t    // this.shadowBlur = Math.floor(this.r);\n\t\n\t    context.save();\n\t    context.translate(this.x, this.y);\n\t    var strokeColor = this.color;\n\t    strokeColor = utils.calculateColor(strokeColor, 1 - this.r / this.maxRadius);\n\t    context.strokeStyle = strokeColor;\n\t    context.shadowBlur = this.shadowBlur;\n\t    context.shadowColor = strokeColor;\n\t    context.lineWidth = this.lineWidth;\n\t    context.beginPath();\n\t    context.arc(0, 0, this.r, 0, Math.PI * 2, false);\n\t    context.stroke();\n\t    context.restore();\n\t\n\t    if (Math.abs(this.maxRadius - this.r) < 0.8) {\n\t      this.r = 0;\n\t    }\n\t  };\n\t\n\t  return P;\n\t}();\n\t\n\tvar Spark = function () {\n\t  var S = function S(options) {\n\t    var startX = options.startX,\n\t        startY = options.startY,\n\t        endX = options.endX,\n\t        endY = options.endY;\n\t\n\t    //两点之间的圆有多个，通过两点及半径便可以定出两个圆，根据需要选取其中一个圆\n\t    var L = Math.sqrt(Math.pow(startX - endX, 2) + Math.pow(startY - endY, 2));\n\t    var m = (startX + endX) / 2; // 横轴中点\n\t    var n = (startY + endY) / 2; // 纵轴中点\n\t    var factor = 1.5;\n\t\n\t    var centerX = (startY - endY) * factor + m;\n\t    var centerY = (endX - startX) * factor + n;\n\t\n\t    var radius = Math.sqrt(Math.pow(L / 2, 2) + Math.pow(L * factor, 2));\n\t    var startAngle = Math.atan2(startY - centerY, startX - centerX);\n\t    var endAngle = Math.atan2(endY - centerY, endX - centerX);\n\t\n\t    // 保证Spark的弧度不超过Math.PI\n\t    if (startAngle * endAngle < 0) {\n\t      if (startAngle < 0) {\n\t        startAngle += Math.PI * 2;\n\t        endAngle += Math.PI * 2;\n\t      } else {\n\t        endAngle += Math.PI * 2;\n\t      }\n\t    }\n\t\n\t    this.tailPointsCount = 5; // 拖尾点数\n\t    this.centerX = centerX;\n\t    this.centerY = centerY;\n\t    this.startAngle = startAngle;\n\t    this.endAngle = endAngle;\n\t    this.radius = radius;\n\t    this.lineWidth = options.width || 5;\n\t    this.strokeStyle = options.color || '#000';\n\t    this.factor = 2 / this.radius;\n\t    this.deltaAngle = 80 / Math.min(this.radius, 400) / this.tailPointsCount;\n\t    this.trailAngle = this.startAngle;\n\t    this.arcAngle = this.startAngle;\n\t\n\t    this.animateBlur = true;\n\t\n\t    this.marker = new Marker({\n\t      x: 50,\n\t      y: 80,\n\t      rotation: 50 * Math.PI / 180,\n\t      style: 'circle',\n\t      color: 'rgb(255, 255, 255)',\n\t      size: 1.5,\n\t      borderWidth: 0,\n\t      borderColor: this.strokeStyle\n\t    });\n\t  };\n\t\n\t  S.prototype.drawArc = function (context, strokeColor, lineWidth, startAngle, endAngle) {\n\t    context.save();\n\t    context.lineWidth = lineWidth;\n\t    // context.lineWidth = 5;\n\t    context.strokeStyle = strokeColor;\n\t    context.shadowColor = this.strokeStyle;\n\t    // context.shadowBlur = 5;\n\t    context.lineCap = \"round\";\n\t    context.beginPath();\n\t    context.arc(this.centerX, this.centerY, this.radius, startAngle, endAngle, false);\n\t    context.stroke();\n\t    context.restore();\n\t  };\n\t\n\t  S.prototype.draw = function (context) {\n\t    var endAngle = this.endAngle;\n\t    // 匀速\n\t    var angle = this.trailAngle + (endAngle - this.startAngle) * this.factor;\n\t    var strokeColor = this.strokeStyle;\n\t    if (this.animateBlur) {\n\t      this.arcAngle = angle;\n\t    }\n\t    this.trailAngle = angle;\n\t    strokeColor = utils.calculateColor(strokeColor, 0.1);\n\t\n\t    this.drawArc(context, strokeColor, this.lineWidth, this.startAngle, this.arcAngle);\n\t\n\t    // 拖尾效果\n\t    var count = this.tailPointsCount;\n\t    for (var i = 0; i < count; i++) {\n\t      var arcColor = utils.calculateColor(this.strokeStyle, 0.3 - 0.3 / count * i);\n\t      var tailLineWidth = 5;\n\t      if (this.trailAngle - this.deltaAngle * i > this.startAngle) {\n\t        this.drawArc(context, arcColor, tailLineWidth - tailLineWidth / count * i, this.trailAngle - this.deltaAngle * i, this.trailAngle);\n\t      }\n\t    }\n\t\n\t    context.save();\n\t    context.translate(this.centerX, this.centerY);\n\t    this.marker.x = Math.cos(this.trailAngle) * this.radius;\n\t    this.marker.y = Math.sin(this.trailAngle) * this.radius;\n\t    this.marker.rotation = this.trailAngle + Math.PI / 2;\n\t    this.marker.draw(context);\n\t    context.restore();\n\t\n\t    if ((endAngle - this.trailAngle) * 180 / Math.PI < 0.5) {\n\t      this.trailAngle = this.startAngle;\n\t      this.animateBlur = false;\n\t    }\n\t  };\n\t\n\t  return S;\n\t}();\n\t\n\t/*\r\n\t * options:{\r\n\t   style:\r\n\t   data:\r\n\t }\r\n\t*/\n\tvar Migration = function Migration(options) {\n\t  // options = {\n\t  //   data: [{\n\t  //     from: [x, y],\n\t  //     to: [x, y],\n\t  //     color: 'rgb()',\n\t  //     value: 8888\n\t  //   }],\n\t  //   context: context\n\t  // };\n\t\n\t  this.data = options.data;\n\t  this.store = {\n\t    arcs: [],\n\t    markers: [],\n\t    pulses: [],\n\t    sparks: []\n\t  };\n\t  this.playAnimation = true;\n\t  this.started = false;\n\t  this.context = options.context;\n\t\n\t  this.init();\n\t};\n\t\n\tMigration.prototype.init = function () {\n\t  this.updateData(this.data);\n\t};\n\t/*\r\n\t * Shape 必须拥有draw方法\r\n\t*/\n\tMigration.prototype.add = function (Shape) {};\n\tMigration.prototype.remove = function () {};\n\tMigration.prototype.clear = function () {\n\t  this.store = {\n\t    arcs: [],\n\t    markers: [],\n\t    pulses: [],\n\t    sparks: []\n\t  };\n\t  // 更新状态\n\t  this.playAnimation = true;\n\t  this.started = false;\n\t  // 清除绘画实例，如果没有这个方法，多次调用start，相当于存在多个动画队列同时进行\n\t  window.cancelAnimationFrame(this.requestAnimationId);\n\t};\n\t/*\r\n\t * 更新数据\r\n\t*/\n\tMigration.prototype.updateData = function (data) {\n\t  if (!data || data.length === 0) {\n\t    return;\n\t  }\n\t  this.clear();\n\t  this.data = data;\n\t  if (this.data && this.data.length > 0) {\n\t    arrayUtils.forEach(this.data, function (element) {\n\t      var arc = new Arc({\n\t        startX: element.from[0],\n\t        startY: element.from[1],\n\t        endX: element.to[0],\n\t        endY: element.to[1],\n\t        labels: element.labels,\n\t        width: 1,\n\t        color: element.color\n\t      });\n\t      var marker = new Marker({\n\t        x: element.to[0],\n\t        y: element.to[1],\n\t        rotation: arc.endAngle + Math.PI / 2,\n\t        style: 'circle',\n\t        color: element.color,\n\t        size: 2,\n\t        borderWidth: 0,\n\t        borderColor: element.color\n\t      });\n\t      var pulse = new Pulse({\n\t        x: element.to[0],\n\t        y: element.to[1],\n\t        // radius: Math.min(Math.max(arc.radius / 10, 20), 30),\n\t        radius: 25,\n\t        color: element.color,\n\t        borderWidth: 3\n\t      });\n\t      var spark = new Spark({\n\t        startX: element.from[0],\n\t        startY: element.from[1],\n\t        endX: element.to[0],\n\t        endY: element.to[1],\n\t        width: 15,\n\t        color: element.color\n\t      });\n\t\n\t      this.store.arcs.push(arc);\n\t      this.store.markers.push(marker);\n\t      this.store.pulses.push(pulse);\n\t      this.store.sparks.push(spark);\n\t    }, this);\n\t  }\n\t};\n\t/*\r\n\t*/\n\tMigration.prototype.start = function (canvas) {\n\t  var that = this;\n\t  if (!this.started) {\n\t    (function drawFrame() {\n\t      that.requestAnimationId = window.requestAnimationFrame(drawFrame, canvas);\n\t\n\t      if (that.playAnimation) {\n\t        //that.context.clearRect(0, 0, canvas.width, canvas.height);\n\t        //canvas.width = canvas.width;\n\t        // 微信浏览器有问题，不许使用这种写法\n\t        canvas.width += 1;\n\t        canvas.width -= 1;\n\t        for (var p in that.store) {\n\t          var shapes = that.store[p];\n\t          for (var i = 0, len = shapes.length; i < len; i++) {\n\t            shapes[i].draw(that.context);\n\t          }\n\t        }\n\t      }\n\t    })();\n\t    this.started = true;\n\t  }\n\t};\n\tMigration.prototype.play = function () {\n\t  this.playAnimation = true;\n\t};\n\tMigration.prototype.pause = function () {\n\t  this.playAnimation = false;\n\t};\n\t\n\t// window.Migration = Migration;\n\tvar QQMapPlugin = window.QQMapPlugin = window.QQMapPlugin || {};\n\t\n\t//声明类,opts为类属性，初始化时传入（非必须，看实际需求）\n\tvar MigrationOverlay = function MigrationOverlay(map, cfg) {\n\t  // options = {\n\t  //   data: [{\n\t  //     from: [lon, lat],\n\t  //     to: [lon, lat],\n\t  //     color: 'rgb()',\n\t  //     value: 8888\n\t  //   }]\n\t  // };\n\t  this.setMap(map);\n\t  this.config = cfg;\n\t  qq.maps.Overlay.call(this);\n\t  this.mapHandles = [];\n\t};\n\t//继承Overlay基类\n\tMigrationOverlay.prototype = new qq.maps.Overlay();\n\t//实现构造方法\n\tMigrationOverlay.prototype.construct = function () {\n\t  //将dom添加到覆盖物层\n\t  this.config.canvas = document.createElement('canvas');\n\t  this.config.context = this.config.canvas.getContext('2d');\n\t  this.getPanes().overlayLayer.appendChild(this.config.canvas);\n\t  this.resize();\n\t\n\t  //var context = this.config.preCanvas.getContext('2d');\n\t  if (!this.migration) {\n\t    var data = this.convertData();\n\t    this.migration = new Migration({\n\t      data: data,\n\t      context: this.config.context\n\t    });\n\t    this.bindMapEvents();\n\t  }\n\t\n\t  this.constructed = true;\n\t  this.draging = false;\n\t};\n\t\n\tMigrationOverlay.prototype.bindMapEvents = function () {\n\t  var that = this;\n\t  this.mapHandles.push(qq.maps.event.addListener(that.map, 'bounds_changed', function () {\n\t    console.info('bounds_changed');\n\t    that.draw();\n\t  }));\n\t  // autoResize 为false时，改变容器不会触发resize事件；\n\t  // autoResize 为true时，map的resize事件会频繁刷新;\n\t  // 所以这里只监控window的resize事件\n\t  window.onresize = function () {\n\t    that.resize();\n\t  };\n\t  this.mapHandles.push(qq.maps.event.addListener(that.map, 'dragstart', function () {\n\t    console.info('map dragstart');\n\t    that.pause();\n\t  }));\n\t  this.mapHandles.push(qq.maps.event.addListener(that.map, 'dragend', function () {\n\t    console.info('map dragend');\n\t    that.play();\n\t    that.draw();\n\t  }));\n\t};\n\t\n\tMigrationOverlay.prototype.resize = function () {\n\t  // 获取map宽高\n\t  var containerStyle = window.getComputedStyle(this.map.getContainer());\n\t  this.config.canvas.style.position = 'absolute';\n\t  this.config.canvas.className = 'migration-overlay';\n\t  this.config.canvas.setAttribute('width', parseInt(containerStyle.width, 10));\n\t  this.config.canvas.setAttribute('height', parseInt(containerStyle.height, 10));\n\t\n\t  // this.transform();\n\t};\n\t\n\tMigrationOverlay.prototype.transform = function () {\n\t  var bounds = this.map.getBounds();\n\t  if (bounds) {\n\t    var topLeft = new qq.maps.LatLng(bounds.getNorthEast().getLat(), bounds.getSouthWest().getLng());\n\t    var projection = this.getProjection();\n\t    var point = projection.fromLatLngToDivPixel(topLeft);\n\t\n\t    // 保证canvas始终叠在左上角而不随map bounds变化而移动\n\t    this.config.canvas.style.transform = 'translate(' + Math.round(point.x) + 'px,' + Math.round(point.y) + 'px)';\n\t  }\n\t};\n\t\n\tMigrationOverlay.prototype.convertData = function () {\n\t  var bounds = this.map.getBounds();\n\t\n\t  if (this.config && this.config.data && bounds) {\n\t    var topLeft = new qq.maps.LatLng(bounds.getNorthEast().getLat(), bounds.getSouthWest().getLng());\n\t    var projection = this.getProjection();\n\t    var layerOffset = projection.fromLatLngToDivPixel(topLeft);\n\t    var data = arrayUtils.map(this.config.data, function (d) {\n\t      var fromPixel = projection.fromLatLngToDivPixel(new qq.maps.LatLng(d.from[1], d.from[0]));\n\t      var toPixel = projection.fromLatLngToDivPixel(new qq.maps.LatLng(d.to[1], d.to[0]));\n\t      // overlay 的左上点默认随着地图初始化时的左上边界移动。\n\t      // 为了保证前迁徙动画能够完整画出，所以必须让canvas占据整个地图视图范围。\n\t      // draw中已经移动了canvas overlay的位置，此处需要靠调整偏移来正确绘制迁徙点的位置\n\t      return {\n\t        from: [fromPixel.getX() - layerOffset.x, fromPixel.getY() - layerOffset.y],\n\t        to: [toPixel.getX() - layerOffset.x, toPixel.getY() - layerOffset.y],\n\t        labels: d.labels,\n\t        value: d.value,\n\t        color: d.color\n\t      };\n\t    }, this);\n\t\n\t    return data;\n\t  }\n\t};\n\t\n\t// 更新数据\n\tMigrationOverlay.prototype.setData = function (data) {\n\t  this.config.data = data;\n\t  this.draw();\n\t};\n\t\n\tMigrationOverlay.prototype.show = function () {\n\t  this.config.canvas.style.display = \"\";\n\t};\n\t\n\tMigrationOverlay.prototype.hide = function () {\n\t  this.config.canvas.style.display = \"none\";\n\t};\n\t\n\tMigrationOverlay.prototype.draw = function () {\n\t  var bounds = this.map.getBounds();\n\t  if (bounds && this.migration.playAnimation) {\n\t    this.transform();\n\t\n\t    var data = this.convertData();\n\t    this.migration.updateData(data);\n\t    this.migration.start(this.config.canvas);\n\t  }\n\t};\n\tMigrationOverlay.prototype.pause = function () {\n\t  this.migration.pause();\n\t};\n\tMigrationOverlay.prototype.play = function () {\n\t  this.migration.play();\n\t};\n\t//实现析构方法（类生命周期结束时会自动调用，用于释放资源等）\n\tMigrationOverlay.prototype.destroy = function () {\n\t  this.migration.clear();\n\t  //移除dom\n\t  this.config.canvas.parentNode.removeChild(this.config.canvas);\n\t  // if (this.changeHandler) {\n\t  //   qq.maps.event.removeListener(this.changeHandler);\n\t  //   this.changeHandler = null;\n\t  // }\n\t  arrayUtils.forEach(this.mapHandles, function (handle) {\n\t    qq.mpas.event.removeListener(handle);\n\t  });\n\t  this.mapHandles = [];\n\t};\n\t\n\tQQMapPlugin[\"MigrationOverlay\"] = MigrationOverlay;\n\t\n\tmodule.exports = MigrationOverlay;\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// main.f0767c3c861601e35fd2.bundle.js","var MigrationOverlay = require('./routes/migration');\r\n\r\nwindow.map=null,\r\nwindow.mOverlay=null,\r\nwindow.onload = function(){\r\n  var data = '[{\"from\":[113.26627,23.13171],\"to\":[108.32754,22.81521],\"labels\":[null,\"广西\"],\"color\":\"#ff3a31\"},{\"from\":[113.26627,23.13171],\"to\":[112.9834,28.11266],\"labels\":[null,\"湖南\"],\"color\":\"#ff7e2b\"},{\"from\":[113.26627,23.13171],\"to\":[115.91004,28.67417],\"labels\":[null,\"江西\"],\"color\":\"#ffc726\"},{\"from\":[113.26627,23.13171],\"to\":[114.34234,30.54539],\"labels\":[null,\"湖北\"],\"color\":\"#e9ff20\"},{\"from\":[113.26627,23.13171],\"to\":[119.29659,26.09982],\"labels\":[null,\"福建\"],\"color\":\"#99ff1b\"},{\"from\":[113.26627,23.13171],\"to\":[106.70722,26.5982],\"labels\":[null,\"贵州\"],\"color\":\"#45ff15\"},{\"from\":[113.26627,23.13171],\"to\":[104.07572,30.65089],\"labels\":[null,\"四川\"],\"color\":\"#10ff33\"},{\"from\":[113.26627,23.13171],\"to\":[120.1536,30.26555],\"labels\":[null,\"浙江\"],\"color\":\"#0aff84\"},{\"from\":[113.26627,23.13171],\"to\":[121.4737,31.23037],\"labels\":[null,\"上海\"],\"color\":\"#05ffd9\"},{\"from\":[113.26627,23.13171],\"to\":[113.75322,34.76571],\"labels\":[null,\"河南\"],\"color\":\"#00ccff\"}]';\r\n    window.map=new qq.maps.Map(document.getElementById(\"map_container\"),{\r\n      zoom:4,\r\n      center:new qq.maps.LatLng(37.43496995956318,106.92269849999998),\r\n      mapTypeId:qq.maps.MapTypeId.ROADMAP\r\n    });\r\n    window.mOverlay=new QQMapPlugin.MigrationOverlay(window.map,{data:JSON.parse(data)});\r\n    new qq.maps.Label({\r\n      position:new qq.maps.LatLng(25.735,123.46777777777777),\r\n      map:window.map,content:\"钓鱼岛\",\r\n      style:{borderStyle:\"none\",color:\"#fff\",backgroundColor:\"transparent\"}}),\r\n    new qq.maps.Label({\r\n      position:new qq.maps.LatLng(25.9175,124.55138888888888),\r\n      map:window.map,\r\n      content:\"赤尾屿\",\r\n      offset:new qq.maps.Size(0,(-10)),\r\n      style:{borderStyle:\"none\",color:\"#fff\",backgroundColor:\"transparent\"}\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/zzPersonal/vue-webpack-starter/client/src/main.js","var MigrationOverlay = require('./migration');\r\n\r\nmodule.exports = MigrationOverlay;\n\n\n// WEBPACK FOOTER //\n// ./C:/zzPersonal/vue-webpack-starter/client/src/routes/migration/index.js","//已知两点和半径求圆心算法：\r\n//http://stackoverflow.com/questions/12264841/determine-circle-center-based-on-two-points-radius-known-with-solve-optim\r\n\r\n  var utils = {\r\n    // color:rgb或rgba格式\r\n    // opacity: 透明度\r\n    calculateColor: function(color, opacity) {\r\n      if (color.indexOf('#') === 0) {\r\n        var color16 = color.slice(1);\r\n        var r = parseInt(color16.slice(0, 2), 16);\r\n        var g = parseInt(color16.slice(2, 4), 16);\r\n        var b = parseInt(color16.slice(4), 16);\r\n        return 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';\r\n      } else if (/^rgb\\(/.test(color)) {\r\n        return color.replace(/rgb/, 'rgba').replace(')', \",\") +\r\n          opacity + ')';\r\n      } else {\r\n        return color.split(',').splice(0, 3).join(',') +\r\n          opacity + ')';\r\n      }\r\n    }\r\n  };\r\n  var arrayUtils = {\r\n    forEach: function(arr, cb, scope) {\r\n      if (typeof Array.prototype.forEach === 'function') {\r\n        arr.forEach(cb, scope);\r\n      } else {\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n          cb.apply(scope, [arr[i], i, arr]);\r\n        }\r\n      }\r\n    },\r\n    map: function(arr, cb, scope) {\r\n      if (typeof Array.prototype.map === 'function') {\r\n        return arr.map(cb, scope);\r\n      } else {\r\n        var mapped = [];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n          mapped[i] = cb.apply(scope, [arr[i], i, arr]);\r\n        }\r\n        return mapped;\r\n      }\r\n    }\r\n  };\r\n\r\n  var Marker = (function() {\r\n    var M = function(options) {\r\n      this.x = options.x;\r\n      this.y = options.y;\r\n      this.rotation = options.rotation;\r\n      this.style = options.style;\r\n      this.color = options.color;\r\n      this.size = options.size;\r\n      this.borderWidth = options.borderWidth;\r\n      this.borderColor = options.borderColor;\r\n    };\r\n\r\n    M.prototype.draw = function(context) {\r\n      context.save();\r\n      context.translate(this.x, this.y);\r\n      context.rotate(this.rotation);\r\n\r\n      context.lineWidth = this.borderWidth || 0;\r\n      context.strokeStyle = this.borderColor || '#000';\r\n      context.fillStyle = this.color || '#000';\r\n      // 目前先只支持圆\r\n        context.beginPath();\r\n      if (this.style === 'circle') {\r\n        context.arc(0, 0, this.size, 0, Math.PI * 2, false);\r\n      } else if (this.style === 'arrow') {\r\n        context.moveTo(-this.size, -this.size);\r\n        context.lineTo(this.size, 0);\r\n        context.lineTo(-this.size, this.size);\r\n        context.lineTo(-this.size / 4, 0);\r\n        context.lineTo(-this.size, -this.size);\r\n      }\r\n      context.closePath();\r\n      context.stroke();\r\n      context.fill();\r\n      context.restore();\r\n    };\r\n\r\n    return M;\r\n  })();\r\n\r\n  var Arc = (function() {\r\n    var A = function(options) {\r\n      var startX = options.startX,\r\n      startY = options.startY,\r\n      endX = options.endX,\r\n      endY = options.endY;\r\n\r\n      //两点之间的圆有多个，通过两点及半径便可以定出两个圆，根据需要选取其中一个圆\r\n      var L = Math.sqrt(Math.pow(startX - endX, 2) + Math.pow(startY - endY, 2));\r\n      var m = (startX + endX) / 2; // 横轴中点\r\n      var n = (startY + endY) / 2; // 纵轴中点\r\n      var factor = 1.5;\r\n\r\n      var centerX = (startY - endY) * factor + m;\r\n      var centerY = (endX - startX) * factor + n;\r\n\r\n      var radius = Math.sqrt(Math.pow(L / 2, 2) + Math.pow(L * factor, 2));\r\n      var startAngle = Math.atan2(startY - centerY, startX - centerX);\r\n      var endAngle = Math.atan2(endY - centerY, endX - centerX);\r\n\r\n      // this.L = L;\r\n      this.startX = startX;\r\n      this.startY = startY;\r\n      this.endX = endX;\r\n      this.endY = endY;\r\n      this.centerX = centerX;\r\n      this.centerY = centerY;\r\n      this.startAngle = startAngle;\r\n      this.endAngle = endAngle;\r\n      this.startLabel = options && options.labels && options.labels[0],\r\n      this.endLabel = options && options.labels && options.labels[1],\r\n      this.radius = radius;\r\n      this.lineWidth = options.width || 1;\r\n      this.strokeStyle = options.color || '#000';\r\n      this.shadowBlur = options.shadowBlur;\r\n    };\r\n\r\n    A.prototype.draw = function(context) {\r\n      context.save();\r\n      context.lineWidth = this.lineWidth;\r\n      context.strokeStyle = this.strokeStyle;\r\n      context.shadowColor = this.strokeStyle;\r\n      context.shadowBlur = this.shadowBlur || 2;\r\n\r\n      context.beginPath();\r\n      context.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, false);\r\n      context.stroke();\r\n      context.restore();\r\n\r\n      context.save();\r\n      context.fillStyle = this.strokeStyle;\r\n      context.font = \"15px sans-serif\";\r\n      if (this.startLabel) {\r\n        var x = this.startLabel.indexOf('澳门') !== -1 ? this.startX - 20 : this.startX;\r\n        var y = this.startLabel.indexOf('澳门') !== -1 ? this.startY + 25 : this.startY;\r\n        context.fillText(this.startLabel, x, y);\r\n      }\r\n      if (this.endLabel) {\r\n        var x = this.endLabel.indexOf('澳门') !== -1 ? this.endX - 20 : this.endX;\r\n        var y = this.endLabel.indexOf('澳门') !== -1 ? this.endY + 25 : this.endY;\r\n        context.fillText(this.endLabel, x, y);\r\n      }\r\n      context.restore();\r\n    };\r\n\r\n    return A;\r\n  })();\r\n\r\n  var Pulse = (function() {\r\n    function P(options) {\r\n      this.x = options.x;\r\n      this.y = options.y;\r\n      this.maxRadius = options.radius;\r\n      this.color = options.color;\r\n      this.shadowBlur = 5;\r\n      this.lineWidth = options.borderWidth;\r\n      this.r = 0;\r\n      this.factor = 2 / options.radius;\r\n    };\r\n\r\n    P.prototype.draw = function(context) {\r\n      // var vr = (this.maxRadius - this.r) * this.factor;\r\n      var vr = 0.5;\r\n      this.r += vr;\r\n      // this.shadowBlur = Math.floor(this.r);\r\n\r\n      context.save();\r\n      context.translate(this.x, this.y);\r\n      var strokeColor = this.color;\r\n      strokeColor = utils.calculateColor(strokeColor, 1 - this.r / this.maxRadius);\r\n      context.strokeStyle = strokeColor;\r\n      context.shadowBlur = this.shadowBlur;\r\n      context.shadowColor = strokeColor;\r\n      context.lineWidth = this.lineWidth;\r\n      context.beginPath();\r\n      context.arc(0, 0, this.r, 0, Math.PI * 2, false);\r\n      context.stroke();\r\n      context.restore();\r\n\r\n      if (Math.abs(this.maxRadius - this.r) < 0.8) {\r\n        this.r = 0;\r\n      }\r\n    }\r\n\r\n    return P;\r\n  })();\r\n\r\n  var Spark = (function() {\r\n    var S = function(options) {\r\n      var startX = options.startX,\r\n      startY = options.startY,\r\n      endX = options.endX,\r\n      endY = options.endY;\r\n\r\n      //两点之间的圆有多个，通过两点及半径便可以定出两个圆，根据需要选取其中一个圆\r\n      var L = Math.sqrt(Math.pow(startX - endX, 2) + Math.pow(startY - endY, 2));\r\n      var m = (startX + endX) / 2; // 横轴中点\r\n      var n = (startY + endY) / 2; // 纵轴中点\r\n      var factor = 1.5;\r\n\r\n      var centerX = (startY - endY) * factor + m;\r\n      var centerY = (endX - startX) * factor + n;\r\n\r\n      var radius = Math.sqrt(Math.pow(L / 2, 2) + Math.pow(L * factor, 2));\r\n      var startAngle = Math.atan2(startY - centerY, startX - centerX);\r\n      var endAngle = Math.atan2(endY - centerY, endX - centerX);\r\n\r\n      // 保证Spark的弧度不超过Math.PI\r\n      if (startAngle * endAngle < 0) {\r\n        if (startAngle < 0) {\r\n          startAngle += Math.PI * 2;\r\n          endAngle += Math.PI * 2;\r\n        } else {\r\n          endAngle += Math.PI * 2;\r\n        }\r\n      }\r\n\r\n      this.tailPointsCount = 5; // 拖尾点数\r\n      this.centerX = centerX;\r\n      this.centerY = centerY;\r\n      this.startAngle = startAngle;\r\n      this.endAngle = endAngle;\r\n      this.radius = radius;\r\n      this.lineWidth = options.width || 5;\r\n      this.strokeStyle = options.color || '#000';\r\n      this.factor = 2 / this.radius;\r\n      this.deltaAngle = (80 / Math.min(this.radius, 400)) / this.tailPointsCount;\r\n      this.trailAngle = this.startAngle;\r\n      this.arcAngle = this.startAngle;\r\n\r\n      this.animateBlur = true;\r\n\r\n      this.marker = new Marker({\r\n        x: 50,\r\n        y:80,\r\n        rotation: 50 * Math.PI / 180,\r\n        style: 'circle',\r\n        color: 'rgb(255, 255, 255)',\r\n        size: 1.5,\r\n        borderWidth: 0,\r\n        borderColor: this.strokeStyle\r\n      });\r\n    };\r\n\r\n    S.prototype.drawArc = function(context, strokeColor, lineWidth, startAngle, endAngle) {\r\n      context.save();\r\n      context.lineWidth = lineWidth;\r\n      // context.lineWidth = 5;\r\n      context.strokeStyle = strokeColor;\r\n      context.shadowColor = this.strokeStyle;\r\n      // context.shadowBlur = 5;\r\n      context.lineCap = \"round\";\r\n      context.beginPath();\r\n      context.arc(this.centerX, this.centerY, this.radius, startAngle, endAngle, false);\r\n      context.stroke();\r\n      context.restore();\r\n    };\r\n\r\n    S.prototype.draw = function(context) {\r\n      var endAngle = this.endAngle;\r\n      // 匀速\r\n      var angle = this.trailAngle + (endAngle - this.startAngle) * this.factor;\r\n      var strokeColor = this.strokeStyle;\r\n      if (this.animateBlur) {\r\n        this.arcAngle = angle;\r\n      }\r\n      this.trailAngle = angle;\r\n      strokeColor = utils.calculateColor(strokeColor, 0.1);\r\n\r\n      this.drawArc(context, strokeColor, this.lineWidth, this.startAngle, this.arcAngle);\r\n\r\n      // 拖尾效果\r\n      var count = this.tailPointsCount;\r\n      for (var i = 0;  i < count; i++) {\r\n        var arcColor = utils.calculateColor(this.strokeStyle, 0.3-0.3/count*i);\r\n        var tailLineWidth = 5;\r\n        if (this.trailAngle - this.deltaAngle * i > this.startAngle)  {\r\n          this.drawArc(context, arcColor,\r\n            tailLineWidth - tailLineWidth / count * i,\r\n            this.trailAngle - this.deltaAngle * i,\r\n            this.trailAngle\r\n          );\r\n        }\r\n      }\r\n\r\n      context.save();\r\n      context.translate(this.centerX, this.centerY);\r\n      this.marker.x = Math.cos(this.trailAngle) * this.radius;\r\n      this.marker.y = Math.sin(this.trailAngle) * this.radius;\r\n      this.marker.rotation = this.trailAngle + Math.PI / 2;\r\n      this.marker.draw(context);\r\n      context.restore();\r\n\r\n      if ((endAngle - this.trailAngle) * 180 / Math.PI < 0.5) {\r\n        this.trailAngle = this.startAngle;\r\n        this.animateBlur = false;\r\n      }\r\n    };\r\n\r\n    return S;\r\n  })();\r\n\r\n  /*\r\n   * options:{\r\n     style:\r\n     data:\r\n   }\r\n  */\r\n  var Migration = function(options) {\r\n    // options = {\r\n    //   data: [{\r\n    //     from: [x, y],\r\n    //     to: [x, y],\r\n    //     color: 'rgb()',\r\n    //     value: 8888\r\n    //   }],\r\n    //   context: context\r\n    // };\r\n\r\n    this.data = options.data;\r\n    this.store = {\r\n      arcs: [],\r\n      markers: [],\r\n      pulses: [],\r\n      sparks: []\r\n    };\r\n    this.playAnimation = true;\r\n    this.started = false;\r\n    this.context = options.context;\r\n\r\n    this.init();\r\n  };\r\n\r\n  Migration.prototype.init = function() {\r\n    this.updateData(this.data);\r\n  };\r\n  /*\r\n   * Shape 必须拥有draw方法\r\n  */\r\n  Migration.prototype.add = function(Shape) {\r\n\r\n  };\r\n  Migration.prototype.remove = function() {\r\n\r\n  };\r\n  Migration.prototype.clear = function() {\r\n    this.store = {\r\n      arcs: [],\r\n      markers: [],\r\n      pulses: [],\r\n      sparks: []\r\n    };\r\n    // 更新状态\r\n    this.playAnimation = true;\r\n    this.started = false;\r\n    // 清除绘画实例，如果没有这个方法，多次调用start，相当于存在多个动画队列同时进行\r\n    window.cancelAnimationFrame(this.requestAnimationId);\r\n  };\r\n  /*\r\n   * 更新数据\r\n  */\r\n  Migration.prototype.updateData = function(data) {\r\n    if (!data || data.length === 0) {\r\n      return;\r\n    }\r\n    this.clear();\r\n    this.data = data;\r\n    if (this.data && this.data.length > 0) {\r\n      arrayUtils.forEach(this.data, function(element) {\r\n        var arc = new Arc({\r\n          startX: element.from[0],\r\n          startY: element.from[1],\r\n          endX: element.to[0],\r\n          endY: element.to[1],\r\n          labels: element.labels,\r\n          width: 1,\r\n          color: element.color\r\n        });\r\n        var marker = new Marker({\r\n          x: element.to[0],\r\n          y: element.to[1],\r\n          rotation: arc.endAngle + Math.PI / 2,\r\n          style: 'circle',\r\n          color: element.color,\r\n          size: 2,\r\n          borderWidth: 0,\r\n          borderColor: element.color\r\n        });\r\n        var pulse = new Pulse({\r\n          x: element.to[0],\r\n          y: element.to[1],\r\n          // radius: Math.min(Math.max(arc.radius / 10, 20), 30),\r\n          radius: 25,\r\n          color: element.color,\r\n          borderWidth: 3\r\n        });\r\n        var spark = new Spark({\r\n          startX: element.from[0],\r\n          startY: element.from[1],\r\n          endX: element.to[0],\r\n          endY: element.to[1],\r\n          width: 15,\r\n          color: element.color\r\n        });\r\n\r\n        this.store.arcs.push(arc);\r\n        this.store.markers.push(marker);\r\n        this.store.pulses.push(pulse);\r\n        this.store.sparks.push(spark);\r\n      }, this);\r\n    }\r\n  };\r\n  /*\r\n  */\r\n  Migration.prototype.start = function(canvas) {\r\n    var that = this;\r\n    if (!this.started) {\r\n      (function drawFrame() {\r\n          that.requestAnimationId = window.requestAnimationFrame(drawFrame, canvas);\r\n\r\n          if (that.playAnimation) {\r\n            //that.context.clearRect(0, 0, canvas.width, canvas.height);\r\n            //canvas.width = canvas.width;\r\n            // 微信浏览器有问题，不许使用这种写法\r\n            canvas.width += 1;\r\n            canvas.width -= 1;\r\n            for (var p in that.store) {\r\n              var shapes = that.store[p];\r\n              for (var i = 0, len = shapes.length; i < len; i++) {\r\n                shapes[i].draw(that.context);\r\n              }\r\n            }\r\n          }\r\n      })();\r\n      this.started = true;\r\n    }\r\n  };\r\n  Migration.prototype.play = function() {\r\n    this.playAnimation = true;\r\n  };\r\n  Migration.prototype.pause = function() {\r\n    this.playAnimation = false;\r\n  };\r\n\r\n  // window.Migration = Migration;\r\n  var QQMapPlugin = window.QQMapPlugin = window.QQMapPlugin || {};\r\n\r\n  //声明类,opts为类属性，初始化时传入（非必须，看实际需求）\r\n  var MigrationOverlay = function(map, cfg){\r\n    // options = {\r\n    //   data: [{\r\n    //     from: [lon, lat],\r\n    //     to: [lon, lat],\r\n    //     color: 'rgb()',\r\n    //     value: 8888\r\n    //   }]\r\n    // };\r\n    this.setMap(map);\r\n    this.config = cfg;\r\n    qq.maps.Overlay.call(this);\r\n    this.mapHandles = [];\r\n  };\r\n  //继承Overlay基类\r\n  MigrationOverlay.prototype = new qq.maps.Overlay();\r\n  //实现构造方法\r\n  MigrationOverlay.prototype.construct = function() {\r\n    //将dom添加到覆盖物层\r\n    this.config.canvas = document.createElement('canvas');\r\n    this.config.context = this.config.canvas.getContext('2d');\r\n    this.getPanes().overlayLayer.appendChild(this.config.canvas);\r\n    this.resize();\r\n\r\n    //var context = this.config.preCanvas.getContext('2d');\r\n    if (!this.migration) {\r\n      var data = this.convertData();\r\n      this.migration = new Migration({\r\n        data: data,\r\n        context: this.config.context\r\n      });\r\n      this.bindMapEvents();\r\n    }\r\n\r\n    this.constructed = true;\r\n    this.draging = false;\r\n  };\r\n\r\n  MigrationOverlay.prototype.bindMapEvents = function() {\r\n    var that = this;\r\n    this.mapHandles.push(qq.maps.event.addListener(\r\n        that.map,\r\n        'bounds_changed',\r\n        function () {\r\n            console.info('bounds_changed');\r\n            that.draw();\r\n        }\r\n    ));\r\n    // autoResize 为false时，改变容器不会触发resize事件；\r\n    // autoResize 为true时，map的resize事件会频繁刷新;\r\n    // 所以这里只监控window的resize事件\r\n    window.onresize = function() {\r\n      that.resize();\r\n    };\r\n    this.mapHandles.push(qq.maps.event.addListener(\r\n        that.map,\r\n        'dragstart',\r\n        function () {\r\n            console.info('map dragstart');\r\n            that.pause();\r\n        }\r\n    ));\r\n    this.mapHandles.push(qq.maps.event.addListener(\r\n        that.map,\r\n        'dragend',\r\n        function () {\r\n            console.info('map dragend');\r\n            that.play();\r\n            that.draw();\r\n        }\r\n    ));\r\n  };\r\n\r\n  MigrationOverlay.prototype.resize = function() {\r\n    // 获取map宽高\r\n    var containerStyle = window.getComputedStyle(this.map.getContainer());\r\n    this.config.canvas.style.position = 'absolute';\r\n    this.config.canvas.className = 'migration-overlay';\r\n    this.config.canvas.setAttribute('width', parseInt(containerStyle.width, 10));\r\n    this.config.canvas.setAttribute('height', parseInt(containerStyle.height, 10));\r\n\r\n    // this.transform();\r\n  };\r\n\r\n  MigrationOverlay.prototype.transform = function() {\r\n    var bounds = this.map.getBounds();\r\n    if (bounds) {\r\n      var topLeft = new qq.maps.LatLng(\r\n          bounds.getNorthEast().getLat(),\r\n          bounds.getSouthWest().getLng()\r\n      );\r\n      var projection = this.getProjection();\r\n      var point = projection.fromLatLngToDivPixel(topLeft);\r\n\r\n      // 保证canvas始终叠在左上角而不随map bounds变化而移动\r\n      this.config.canvas.style.transform = 'translate(' +\r\n      Math.round(point.x) + 'px,' +\r\n      Math.round(point.y) + 'px)';\r\n    }\r\n  };\r\n\r\n  MigrationOverlay.prototype.convertData = function() {\r\n    var bounds = this.map.getBounds();\r\n\r\n    if (this.config && this.config.data && bounds) {\r\n      var topLeft = new qq.maps.LatLng(\r\n          bounds.getNorthEast().getLat(),\r\n          bounds.getSouthWest().getLng()\r\n      );\r\n      var projection = this.getProjection();\r\n      var layerOffset = projection.fromLatLngToDivPixel(topLeft);\r\n      var data = arrayUtils.map(this.config.data, function(d) {\r\n        var fromPixel = projection.fromLatLngToDivPixel(new qq.maps.LatLng(d.from[1], d.from[0]));\r\n        var toPixel = projection.fromLatLngToDivPixel(new qq.maps.LatLng(d.to[1], d.to[0]));\r\n        // overlay 的左上点默认随着地图初始化时的左上边界移动。\r\n        // 为了保证前迁徙动画能够完整画出，所以必须让canvas占据整个地图视图范围。\r\n        // draw中已经移动了canvas overlay的位置，此处需要靠调整偏移来正确绘制迁徙点的位置\r\n        return {\r\n          from: [fromPixel.getX() - layerOffset.x, fromPixel.getY() - layerOffset.y],\r\n          to: [toPixel.getX() - layerOffset.x, toPixel.getY() - layerOffset.y],\r\n          labels: d.labels,\r\n          value: d.value,\r\n          color: d.color\r\n        }\r\n      }, this);\r\n\r\n      return data;\r\n    }\r\n  };\r\n\r\n  // 更新数据\r\n  MigrationOverlay.prototype.setData = function(data) {\r\n    this.config.data = data;\r\n    this.draw();\r\n  };\r\n\r\n  MigrationOverlay.prototype.show = function() {\r\n    this.config.canvas.style.display = \"\";\r\n  };\r\n\r\n  MigrationOverlay.prototype.hide = function() {\r\n    this.config.canvas.style.display = \"none\";\r\n  };\r\n\r\n  MigrationOverlay.prototype.draw = function() {\r\n    var bounds = this.map.getBounds();\r\n    if (bounds && this.migration.playAnimation) {\r\n      this.transform();\r\n\r\n      var data = this.convertData();\r\n      this.migration.updateData(data);\r\n      this.migration.start(this.config.canvas);\r\n    }\r\n  };\r\n  MigrationOverlay.prototype.pause = function() {\r\n    this.migration.pause();\r\n  };\r\n  MigrationOverlay.prototype.play = function() {\r\n    this.migration.play();\r\n  };\r\n  //实现析构方法（类生命周期结束时会自动调用，用于释放资源等）\r\n  MigrationOverlay.prototype.destroy = function() {\r\n    this.migration.clear();\r\n    //移除dom\r\n    this.config.canvas.parentNode.removeChild(this.config.canvas);\r\n    // if (this.changeHandler) {\r\n    //   qq.maps.event.removeListener(this.changeHandler);\r\n    //   this.changeHandler = null;\r\n    // }\r\n    arrayUtils.forEach(this.mapHandles, function(handle) {\r\n      qq.mpas.event.removeListener(handle);\r\n    });\r\n    this.mapHandles = [];\r\n  };\r\n\r\n  QQMapPlugin[\"MigrationOverlay\"] = MigrationOverlay;\r\n\r\n  module.exports = MigrationOverlay;\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/zzPersonal/vue-webpack-starter/client/src/routes/migration/migration.js"],"sourceRoot":""}